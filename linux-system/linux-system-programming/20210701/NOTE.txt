- c standard를 사용한 io
- 표준 입출력(stdio)
- 표준 입출력함수를 사용한다는것은 c library에 구현된 c 라이브러리 함수를 사용한다는 의미
 : 예, fgetc, fegts등
 
 - 왜 사용해야 할까?
 : 입출력의 처리방식부터 알아야한다.
 : 입출력은 디스크(혹은 메모리)로부터 블록단위로 이루어진다.
 : 문제는 사용자의 코드가 블록단위가 아닌 크기의 바이트를 읽고 쓸때의 성능하락이 발생.
 : 이 블록단위를 좀더 추상화해서 사용자영역의 버퍼를 사용한 입출력을 수행할 수 있도록하여 성능향상을 도모한다.

 - 단점
  : 장점이 단점으로 변한다. 사용자영역 버퍼링을 통해 블룩단위 메모리 정렬을 자동화(?)하지만
    사용자버퍼에서 커널버퍼로의 복사가 다시 이루어져야 한다. 곧 실제 데이터를 쓰고 읽기까지 두번의 복사가 이루어짐
  : 이를 해결하기 위해 개발자가 고유의 버퍼링을 사용할 수도 있다.

- 어떻게?
 : 표준입출력은 FILE구조체를 사용하여 다루어 진다.(리눅스 시스템콜에서는 fd를 사용)
 : setvbuf 함수를 통해 버퍼링방식(정확히는 버퍼링 단위인)을 제어할 수 있다.(미사용, 행단위, 블록단위)

 - 쓰레딩
  : 표준입출력 함수 자체는 쓰레드 세이프(내부적으로 락처리)
  : 하지만 스트림단위의 동기화는 되지 않음
  : 이를 위해 스트림단위의 lock을 제공함 flockfile.
  : 세마포어와 동일하게?(유사하게?) 동작. 자원을 획득할때 카운트가 증가하고 해제할때 감소 (이거왜이레..)
  : 재귀적으로도 호출가능. 하나의 쓰레드가 여러번 호출(단 그 횟수만큼 해제도 해야함)
  : 물론 어떤락도 제공하지 않는 버전도 제공 _unlocked 함수들.(이건 스트림에 대한 락이 아니라 함수에 대한 락)
    : 즉, 내부적으로 락처리를 하지 않는 쓰레드세이프하지 않은 함수를 제공하여 성능향상 가능.(개발자가 직접 제어)