요청을 보내는 sender와 해당 요청을 받아서 처리하는 receiver.
다른말로는 특정행위를 하기 위해 어떤 객체가 다른객체의 함수를 호출하는 경우.
```
struct A{
  void Func(){
    B b;
    b.Foo();
  }
}
```
이 A와 B 둘사이의 커플링을 줄이기 위함.
이런 경우 런타임에 동작을 변경할 수 없고 컴파일 타임에 동작이 정의됨. -> 유연성이 떨어짐.
그리고 책임연쇄라는 말과 같이 처리할 수 없는 요청에 대해서는 체인에 연결된 다른 객체로 책임을 넘김.
위 기능을 위해서는 후행자(successor)를 알고 있어야 함.
즉 요청을 처리할 책임이 있는 객체들의 체인을 만드는 것.

구현을 위해 요청을 처리할 handler를 베이스 클래스로 만들고 handler클래스를 상속받아서 요청을 처리할 클래스를 만듦.
sender가 요청을 보내면, 최초로 요청을 받은 receiver가(handler를 상속받은) 
1. 요청을 바로 처리하거나
2. 다른 receiver로 요청을 넘기거나.

둘 중 하나의 동작을 하게 됨.

하지만 요청을 처리하는 chain구조에서 마지막 객체까지 도달하였을 때 아무 동작도 안할 수도 있음.
이때에 대한 처리가 필요할 듯.
예제의 ReceiverFinal의 역할이 chain에서 무조건 마지막에 오는 구조가 필요.

handler클래스를 상속받아 receiver들이 구현되지만, is-a관계를 의미하진 않음.
*mixin class 내용 참고.
