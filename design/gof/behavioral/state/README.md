객체의 상태가 변함에 따라 동작을 변화시키기 위함.

상태를 표현하기 위한 추상클래스. XXState
추상클래스에서는 각 상태에 따른 행위를 하기 위한 인터페이스가 있고,
해당 추상클래스를 상속받은 구현클래스가 각 상태에 맞는 인터페이스 구현을 가짐.

상태가 변경되면 구현클래스 인스턴스 자체를 변경시킴.

따라서, 다음과 같은 상황에서 활용가능
1. 객체의 행위가 객체의 상태에 따라 변경되어야 할 때. 런타임에!
2. 기능의 분기가 많을 때. if-else 나 switch 같은 구문이 많을때, 

context, state, concrete state로 구성

context는 state참조를 가지고 concrete state에 대한 오너십을 가져야함.
state는 캡슐화된 인터페이스로써, context의 상태와 관련된 행위를 캡슐화함.
concrete state는 state의 구현체. 실제 행위를 구현.

클라이언트는 context를 통해 원하는 동작을 요청. 각 상태에 따른 상세한 동작은 관여하지 않음.

상태마다 state subclass를 추가구현해야 하므로 전체적인 소스코드의 양이 늘어날 수 있지만,
보다 명시적으로 상태에 따른 행위를 정의할 수 있고, 확장이 유연함.
보통 상태에 따른 동작의 구분을 할 때, 상태값을 저장하는 변수와 해당 변수를 기준으로 분기를 하게됨.
이때 어떤 상태와 그에 따른 동작을 추가 하기 위해선 분기문에 추가 조건을 생성하게 되고,
이는 유지보수를 어렵게 만듦.(그런가..? 예제가 필요함.)  
  -> 상태에 따른 동작을 정의한 context의 수정 없이 유지보수할 수 없음. 조건문을 추가해야 되니깐.
또한 상태의 변경을 명시적으로 만들 수 있음. 기존의 상태변수를 변경하는 방법은 코드상에서 봤을 때,
단순히 변수에 새로운 상태값을 대입하는 구문이 됨.

상태클래스가 내부에 상태정보를 유지해야 하냐 말아야 하냐를 고려.
내부에 상태정보를 유지하지 않아도 되는경우, 인터페이스 함수만 있고, 이때는 싱글턴으로 구현할 수 도 있다.

상태를 변경하는 주체가 다름.
기존 구현의 경우 context가 분기문으로 상태를 변경하고 동작을 수행한다면,
state패턴의 경우 각 상태가 변경될 때 state인스턴스 자체가 context의 state변경 함수를 호출해서
상태를 변경시킴. 따라서 context는 상태에 따른 어떤것들을 신경쓰지 않아도 됨.
